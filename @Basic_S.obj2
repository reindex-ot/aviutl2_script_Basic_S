--[[
MIT License
Copyright (c) 2025 sigma-axis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

https://mit-license.org/
]]
@角丸矩形
--information:角丸矩形@Basic_S v1.70 (for beta26) by σ軸
--label:Basic_S\図形
--track@width:幅,0,4000,100,1
--track@height:高さ,0,4000,100,1
--track@line:ライン幅,0,4000,4000,0.01
--color@color:色,0xffffff
--color@color_back:背景色,0xffffff
--track@alpha_back:背景透明度,0,100,100,0.01
--track@radius:角半径,0,2000,40,0.01
--select@shape:丸角形状=0,円=0,円(凹)=1,菱形=2,四角形(凹)=3,正8角形=4,正8角形(凹)=5,正8角形(凹斜)=6,正12角形=7,正12角形(凹)=8,正12角形(凹斜)=9,スパイク=10,スパイク(凹)=11
--group:配置,false
--track@align_x:水平揃え,-100,100,0,0.001
--track@align_y:垂直揃え,-100,100,0,0.001
--group:丸角設定,false
--check@uniform:半径均一,true
--track@r_RT:右上半径,0,2000,40,0.01
--track@r_RB:右下半径,0,2000,40,0.01
--track@r_LB:左下半径,0,2000,40,0.01
--track@aspect:丸角縦横比,-100,100,0,0.001
--check@fixed_aspect:丸角縦横比固定,true
--group:その他,false
--value@PI:PI,{}
--[[pixelshader@combine:
Texture2D chm : register(t0);
Texture2D bkg : register(t1);
cbuffer constant0 : register(b0) {
	float a_back;
};
float4 combine(float4 pos : SV_Position) : SV_Target
{
	float4
		col_bkg = bkg.Load(int3(pos.xy, 0)),
		col_chm = chm.Load(int3(pos.xy, 0));
	col_bkg *= a_back * max(1 - (col_bkg.a > 0 ? col_chm.a / col_bkg.a : 0), 0);
	return col_chm + col_bkg;
}
]]
local obj, math, tonumber, type, buffer = obj, math, tonumber, type, require("string.buffer");

-- take parameters.
--[==[
	PI = {
		width:			number?,
		height:			number?,
		align_x:		number?,
		align_y:		number?,
		line:			number?,
		color:			number?,
		color_back:		number?,
		alpha_back:		number?,
		radii:			table|number|nil,
		fixed_aspect:	boolean|number|nil,
		shapes:			table|string|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
align_x = tonumber(PI.align_x) or align_x;
align_y = tonumber(PI.align_y) or align_y;
line = tonumber(PI.line) or line;
color = tonumber(PI.color) or color;
color_back = tonumber(PI.color_back) or color_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
fixed_aspect = as_bool(PI.fixed_aspect, fixed_aspect) and 1 or 0;

-- normalize parameters.
width = math.max(math.floor(0.5 + width), 0);
height = math.max(math.floor(0.5 + height), 0);
align_x = math.min(math.max(align_x / 100, -1), 1);
align_y = math.min(math.max(align_y / 100, -1), 1);
line = math.max(line, 0);
color = math.floor(0.5 + color) % 2 ^ 24;
color_back = math.floor(0.5 + color_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);


-- further calculations.
if width <= 0 or height <= 0 then return end
local big_radius = math.max(width, height, 4000);
if color == color_back and alpha_back >= 1 then line = big_radius end
local do_fill = 2 * line - 1 >= math.min(width, height);
local shape_name = ({
	"円", "円(凹)", "菱形", "四角形(凹)",
	"正8角形", "正8角形(凹)", "正8角形(凹斜)", "正12角形", "正12角形(凹)", "正12角形(凹斜)",
	"スパイク", "スパイク(凹)",
})[shape + 1] or "円";

-- make rectangle.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.cx, obj.cy = -width * align_x / 2, -height * align_y / 2;
if line <= 0 and alpha_back <= 0 then return end

-- parepare the common parameters.
local function full_escape_repl(s) return "\\"..s:byte() end
local function full_escape(s) return ("%q"):format(s):gsub("[\128-\255]", full_escape_repl) end
local pi_head = ("radii=require'string.buffer'.decode%s,shapes=require'string.buffer'.decode%s,line="):format(
	full_escape(buffer.encode(PI.radii)), full_escape(buffer.encode(PI.shapes)));

-- render the background first.
if do_fill or alpha_back > 0 then
	obj.clearbuffer("object", do_fill and color or color_back);
	obj.effect("四隅丸め@Basic_S", "半径", radius,
		"半径均一", uniform and 1 or 0, "右上半径", r_RT, "右下半径", r_RB, "左下半径", r_LB,
		"縦横比", aspect, "縦横比固定", fixed_aspect, "形状", shape_name, "PI",
		pi_head..math.max(width, height, 4000));
	if do_fill then return end
	if line <= 0 then
		if alpha_back < 1 then
			obj.effect("透明度適用@Basic_S", "透明度", 100 * (1 - alpha_back));
		end
		return;
	end
	obj.copybuffer("tempbuffer", "object");
end

-- next the chrome part.
if line > 0 then
	obj.clearbuffer("object", color);
	obj.effect("四隅丸め@Basic_S", "半径", radius,
		"半径均一", uniform and 1 or 0, "右上半径", r_RT, "右下半径", r_RB, "左下半径", r_LB,
		"縦横比", aspect, "縦横比固定", fixed_aspect, "形状", shape_name, "PI",
		pi_head..line);
else obj.clearbuffer("object") end

-- combine them by shader.
obj.pixelshader("combine", "object", { "object", "tempbuffer" }, {
	alpha_back;
});

@楕円
--information:楕円@Basic_S v1.70 (for beta26) by σ軸
--label:Basic_S\図形
--track@width:幅,0,4000,100,1
--track@height:高さ,0,4000,100,1
--track@line:ライン幅,0,4000,4000,0.01
--color@color:色,0xffffff
--color@color_back:背景色,0xffffff
--track@alpha_back:背景透明度,0,100,100,0.01
--check@circle:真円,false
--group:配置,false
--track@align_x:水平揃え,-100,100,0,0.001
--track@align_y:垂直揃え,-100,100,0,0.001
--group:その他,false
--value@PI:PI,{}
--[[pixelshader@combine:
Texture2D chm : register(t0);
Texture2D bkg : register(t1);
cbuffer constant0 : register(b0) {
	float a_back;
};
float4 combine(float4 pos : SV_Position) : SV_Target
{
	float4
		col_bkg = bkg.Load(int3(pos.xy, 0)),
		col_chm = chm.Load(int3(pos.xy, 0));
	col_bkg *= a_back * max(1 - (col_bkg.a > 0 ? col_chm.a / col_bkg.a : 0), 0);
	return col_chm + col_bkg;
}
]]
local obj, math, tonumber, type = obj, math, tonumber, type;

-- take parameters.
--[==[
	PI = {
		width:		number?,
		height:		number?,
		align_x:	number?,
		align_y:	number?,
		line:		number?,
		color:		number?,
		color_back:	number?,
		alpha_back:	number?,
		circle:		boolean|number|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
align_x = tonumber(PI.align_x) or align_x;
align_y = tonumber(PI.align_y) or align_y;
line = tonumber(PI.line) or line;
color = tonumber(PI.color) or color;
color_back = tonumber(PI.color_back) or color_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
circle = as_bool(PI.circle, circle);

-- normalize parameters.
width = math.max(math.floor(0.5 + width), 0);
height = math.max(math.floor(0.5 + height), 0);
align_x = math.min(math.max(align_x / 100, -1), 1);
align_y = math.min(math.max(align_y / 100, -1), 1);
line = math.max(line, 0);
color = math.floor(0.5 + color) % 2 ^ 24;
color_back = math.floor(0.5 + color_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);

-- further calculations.
if circle then height = width end
if width <= 0 or height <= 0 then return end
local big_radius = math.max(width, height, 4000);
if color == color_back and alpha_back >= 1 then line = big_radius end
local do_fill = 2 * line - 1 >= math.min(width, height);

-- make rectangle.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.cx, obj.cy = -width * align_x / 2, -height * align_y / 2;
if line <= 0 and alpha_back <= 0 then return end

-- render the background first.
if do_fill or alpha_back > 0 then
	obj.clearbuffer("object", do_fill and color or color_back);
	obj.effect("四隅丸め@Basic_S", "半径", big_radius,
		"縦横比固定", 0, "形状", "円", "PI", "line="..big_radius);
	if do_fill then return end
	if line <= 0 then
		if alpha_back < 1 then
			obj.effect("透明度適用@Basic_S", "透明度", 100 * (1 - alpha_back));
		end
		return;
	end
	obj.copybuffer("tempbuffer", "object");
end

-- next the chrome part.
obj.clearbuffer("object", color);
obj.effect("四隅丸め@Basic_S", "半径", big_radius,
	"縦横比固定", 0, "形状", "円", "PI", "line="..line);

-- combine them by shader.
obj.pixelshader("combine", "object", { "object", "tempbuffer" }, {
	alpha_back;
});

@菱形
--information:菱形@Basic_S v1.70 (for beta26) by σ軸
--label:Basic_S\図形
--track@width:幅,0,4000,100,1
--track@height:高さ,0,4000,100,1
--track@line:ライン幅,0,4000,4000,0.01
--color@color:色,0xffffff
--color@color_back:背景色,0xffffff
--track@alpha_back:背景透明度,0,100,100,0.01
--check@square:正方形,false
--group:配置,false
--track@align_x:水平揃え,-100,100,0,0.001
--track@align_y:垂直揃え,-100,100,0,0.001
--group:その他,false
--value@PI:PI,{}
--[[pixelshader@combine:
Texture2D chm : register(t0);
Texture2D bkg : register(t1);
cbuffer constant0 : register(b0) {
	float a_back;
};
float4 combine(float4 pos : SV_Position) : SV_Target
{
	float4
		col_bkg = bkg.Load(int3(pos.xy, 0)),
		col_chm = chm.Load(int3(pos.xy, 0));
	col_bkg *= a_back * max(1 - (col_bkg.a > 0 ? col_chm.a / col_bkg.a : 0), 0);
	return col_chm + col_bkg;
}
]]
local obj, math, tonumber, type = obj, math, tonumber, type;

-- take parameters.
--[==[
	PI = {
		width:		number?,
		height:		number?,
		align_x:	number?,
		align_y:	number?,
		line:		number?,
		color:		number?,
		color_back:	number?,
		alpha_back:	number?,
		square:		boolean|number|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
align_x = tonumber(PI.align_x) or align_x;
align_y = tonumber(PI.align_y) or align_y;
line = tonumber(PI.line) or line;
color = tonumber(PI.color) or color;
color_back = tonumber(PI.color_back) or color_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
square = as_bool(PI.square, square);

-- normalize parameters.
width = math.max(math.floor(0.5 + width), 0);
height = math.max(math.floor(0.5 + height), 0);
align_x = math.min(math.max(align_x / 100, -1), 1);
align_y = math.min(math.max(align_y / 100, -1), 1);
line = math.max(line, 0);
color = math.floor(0.5 + color) % 2 ^ 24;
color_back = math.floor(0.5 + color_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);

-- further calculations.
if square then height = width end
if width <= 0 or height <= 0 then return end
local big_radius = math.max(width, height, 4000);
if color == color_back and alpha_back >= 1 then line = big_radius end
local do_fill = 2 * line - 1 >= math.min(width, height);

-- make rectangle.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.cx, obj.cy = -width * align_x / 2, -height * align_y / 2;
if line <= 0 and alpha_back <= 0 then return end

-- render the background first.
if do_fill or alpha_back > 0 then
	obj.clearbuffer("object", do_fill and color or color_back);
	obj.effect("四隅丸め@Basic_S", "半径", big_radius,
		"縦横比固定", 0, "形状", "菱形", "PI", "line="..big_radius);
	if do_fill then return end
	if line <= 0 then
		if alpha_back < 1 then
			obj.effect("透明度適用@Basic_S", "透明度", 100 * (1 - alpha_back));
		end
		return;
	end
	obj.copybuffer("tempbuffer", "object");
end

-- next the chrome part.
obj.clearbuffer("object", color);
obj.effect("四隅丸め@Basic_S", "半径", big_radius,
	"縦横比固定", 0, "形状", "菱形", "PI", "line="..line);

-- combine them by shader.
obj.pixelshader("combine", "object", { "object", "tempbuffer" }, {
	alpha_back;
});

@スーパー楕円
--information:スーパー楕円@Basic_S v1.70 (for beta26) by σ軸
--label:Basic_S\図形
--track@exponent:膨らみ,-300,300,-60,0.001
--track@width:幅,0,4000,100,1
--track@height:高さ,0,4000,100,1
--track@line:ライン幅,0,4000,4000,1
--color@color:色,0xffffff
--color@color_back:背景色,0xffffff
--track@alpha_back:背景透明度,0,100,100,0.01
--check@symmetric:縦横一致,false
--group:配置,false
--track@align_x:水平揃え,-100,100,0,0.001
--track@align_y:垂直揃え,-100,100,0,0.001
--group:その他,false
--value@PI:PI,{}
--[[pixelshader@carve:
cbuffer constant0 : register(b0) {
	float2 r_hsize; float e;
};
float4 carve(float4 pos : SV_Position) : SV_Target
{
	const float2 p = r_hsize * pos.xy - 1;
	const float v = 1 - dot(pow(abs(p), e), 1),
		d = fwidth(v),
		l = d > 0 ? v / d : sign(v);
	return float4(0, 0, 0, saturate(l + 0.5));
}
]]
local obj, math, tonumber, type = obj, math, tonumber, type;

-- take parameters.
--[==[
	PI = {
		exponent:	number?,
		width:		number?,
		height:		number?,
		align_x:	number?,
		align_y:	number?,
		line:		number?,
		color:		number?,
		color_back:	number?,
		alpha_back:	number?,
		symmetric:	boolean|number|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
exponent = tonumber(PI.exponent) or exponent;
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
align_x = tonumber(PI.align_x) or align_x;
align_y = tonumber(PI.align_y) or align_y;
line = tonumber(PI.line) or line;
color = tonumber(PI.color) or color;
color_back = tonumber(PI.color_back) or color_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
symmetric = as_bool(PI.symmetric, symmetric);

-- normalize parameters.
exponent = math.min(math.max(exponent / 100, -3), 3);
width = math.max(math.floor(0.5 + width), 0);
height = math.max(math.floor(0.5 + height), 0);
align_x = math.min(math.max(align_x / 100, -1), 1);
align_y = math.min(math.max(align_y / 100, -1), 1);
line = math.max(math.floor(0.5 + line), 0);
color = math.floor(0.5 + color) % 2 ^ 24;
color_back = math.floor(0.5 + color_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);

-- further calculations.
if symmetric then height = width end
if width <= 0 or height <= 0 then return end
local big_radius = math.max(width, height, 4000);
if color == color_back and alpha_back >= 1 then line = big_radius end
local do_fill = 2 * line - 1 >= math.min(width, height);

-- make rectangle.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.cx, obj.cy = -width * align_x / 2, -height * align_y / 2;
if line <= 0 and alpha_back <= 0 then return end
obj.clearbuffer("object", do_fill and color or color_back);

-- e = (3 + e')/(3 - e'), astroid at e' = -3/5.
-- e = 0 is replaced by some E < log(2)/log((w/2) / 0.5),
-- e = oo can be replaced by some E > -log(2)/log(1-0.5/w);
-- where w is the maximum possible length.
local e = (3 + exponent) / (3 - exponent);
if exponent >= 3 or e > 1.39 * math.max(width, height) then
	-- e is recognized as inifinity (log(2) ~ 0.693147).
	-- nothing to do.
else
	if exponent <= -3 or e < 1 / 14 then
		-- e is recognized as zero.
		e = 1 / 14; -- max(w, h) is at most 2 ^ 14.
	end
	-- carve the shape by shader.
	obj.pixelshader("carve", "object", nil, {
		2 / width, 2 / height; e;
	}, "mask");
end

-- draw the outline.
if not do_fill then
	obj.effect("縁取りα@Basic_S", "サイズ", -line, "ぼかし", 0,
		"縁色", color, "前景透明度", 100 * (1 - alpha_back))
end

@別レイヤー
--information:別レイヤー@Basic_S v1.70 (for beta26) by σ軸
--label:Basic_S
--select@index_base:レイヤー位置=1,絶対指定=0,相対指定=1
--value@index:番号,-1
--group:復元項目,true
--check@effect:フィルタ効果,true
--check@position:位置の復元,false
--check@rotation:回転拡大の復元,false
--check@alpha:透明度の復元,false
--group:その他,false
--value@PI:PI,{}
local obj, tonumber, type = obj, tonumber, type;

-- take parameters.
--[==[
	PI = {
		index_base:	string?,
		index:		number?,
		effect:		boolean|number|nil,
		position:	boolean|number|nil,
		rotation:	boolean|number|nil,
		alpha:		boolean|number|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
if PI.index_base then
	local name2num = {
		["絶対指定"] = 0, ["相対指定"] = 1,
	};
	index_base = name2num[PI.index_base] or index_base;
end
index = tonumber(PI.index) or tonumber(index) or -1;
effect = as_bool(PI.effect, effect);
position = as_bool(PI.position, position);
rotation = as_bool(PI.rotation, rotation);
alpha = as_bool(PI.alpha, alpha);

-- normalize parameters.
if index_base == 1 then index = obj.layer + index end
if index == obj.layer or index <= 0 then return end -- invalid layer index.

-- load the layer.
local gv, hdr = obj.getvalue, "layer"..index;
if not gv(hdr) then return end -- no object on the layer.
obj.load("layer", index, effect);
if obj.w <= 0 or obj.h <= 0 then return end -- failed to load the layer.

-- restore properties.
-- note that fields like `obj.ox` are initialized to default,
-- even if the object on the target layer had modified them.
if position then
	obj.ox = gv(hdr..".x");
	obj.oy = gv(hdr..".y");
	obj.oz = gv(hdr..".z");

	obj.cx = gv(hdr..".cx");
	obj.cy = gv(hdr..".cy");
	obj.cz = gv(hdr..".cz");
end
if rotation then
	local rx, ry, rz, sx, sy, sz =
		gv(hdr..".rx"), gv(hdr..".ry"), gv(hdr..".rz"),
		gv(hdr..".sx"), gv(hdr..".sy"), gv(hdr..".sz");

	local my_cx, my_cy, my_cz, my_rx, my_ry, my_rz =
		gv("cx"), gv("cy"), gv("cz"), gv("rx"), gv("ry"), gv("rz");

	-- revert the object states first.
	obj.cx, obj.cy, obj.cz, obj.rx, obj.ry, obj.rz =
		obj.cx - my_cx, obj.cy - my_cy, obj.cz - my_cz,
		rx - my_rx, ry - my_ry, rz - my_rz;

	-- apply the reverted center.
	rx, ry, rz = math.pi / 180 * rx, math.pi / 180 * ry, math.pi / 180 * rz;
	local c_x, s_x, c_y, s_y, c_z, s_z =
		math.cos(rx), -math.sin(rx), math.cos(ry), -math.sin(ry), math.cos(rz), -math.sin(rz);
	my_cy, my_cz = c_x * my_cy - s_x * my_cz, s_x * my_cy + c_x * my_cz;
	my_cz, my_cx = c_y * my_cz - s_y * my_cx, s_y * my_cz + c_y * my_cx;
	my_cx, my_cy = c_z * my_cx - s_z * my_cy, s_z * my_cx + c_z * my_cy;
	my_cx, my_cy, my_cz = my_cx / sx, my_cy / sy, my_cz / sz;
	obj.cx, obj.cy, obj.cz = obj.cx + my_cx, obj.cy + my_cy, obj.cz + my_cz;

	-- apply the scaling.
	obj.sx, obj.sy, obj.sz = sx, sy, sz;

	-- apply the reverted rotation.
	if my_rx ~= 0 or my_ry ~= 0 or my_rz ~= 0 then
		obj.effect("XYZ追加回転@Basic_S", "PI",
			([[X=%s,Y=%s,Z=%s]]):format(my_rx, my_ry, my_rz));
	end
end
if alpha then
	obj.alpha = gv(hdr..".alpha");
end
