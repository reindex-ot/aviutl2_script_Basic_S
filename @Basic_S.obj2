--[[
MIT License
Copyright (c) 2025 sigma-axis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

https://mit-license.org/
]]
@角丸矩形
--information:角丸矩形@Basic_S v1.10 (for beta19a) by σ軸
--label:Basic_S\図形
--track@width:幅,0,4000,100,1
--track@height:高さ,0,4000,100,1
--track@align_x:水平揃え,-100,100,0,0.001
--track@align_y:垂直揃え,-100,100,0,0.001
--track@line:ライン幅,0,4000,4000,0.01
--color@color:色,0xffffff
--color@color_back:背景色,0xffffff
--track@alpha_back:背景透明度,0,100,100,0.01
--track@radius:角半径,0,2000,40,0.01
--check@uniform:半径均一,1
--track@r_RT:右上半径,0,2000,40,0.01
--track@r_RB:右下半径,0,2000,40,0.01
--track@r_LB:左下半径,0,2000,40,0.01
--track@aspect:丸角縦横比,-100,100,0,0.001
--check@fixed_aspect:丸角縦横比固定,1
--select@shape:丸角形状=0,円=0,円(凹)=1,菱形=2,四角形(凹)=3,正8角形=4,正8角形(凹)=5,正8角形(凹斜)=6,正12角形=7,正12角形(凹)=8,正12角形(凹斜)=9,スパイク=10,スパイク(凹)=11
--value@PI:PI,{}
--[[pixelshader@combine:
Texture2D chm : register(t0);
Texture2D bkg : register(t1);
cbuffer constant0 : register(b0) {
	float a_back;
};
float4 combine(float4 pos : SV_Position) : SV_Target
{
	float4
		col_bkg = bkg.Load(int3(pos.xy, 0)),
		col_chm = chm.Load(int3(pos.xy, 0));
	col_bkg *= a_back * max(1 - (col_bkg.a > 0 ? col_chm.a / col_bkg.a : 0), 0);
	return col_chm + col_bkg;
}
]]
local obj, math, tonumber, tostring, type, pairs, table, buffer = obj, math, tonumber, tostring, type, pairs, table, require("string.buffer");

-- take parameters.
--[==[
	PI = {
		width:			number?,
		height:			number?,
		align_x:		number?,
		align_y:		number?,
		line:			number?,
		color:			number?,
		color_back:		number?,
		alpha_back:		number?,
		radii:			table|number|nil,
		fixed_aspect:	boolean|number|nil,
		shapes:			table|string|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
align_x = tonumber(PI.align_x) or align_x;
align_y = tonumber(PI.align_y) or align_y;
line = tonumber(PI.line) or line;
color = tonumber(PI.color) or color;
color_back = tonumber(PI.color_back) or color_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
fixed_aspect = as_bool(PI.fixed_aspect, fixed_aspect ~= 0) and 1 or 0;

-- normalize parameters.
width = math.max(math.floor(0.5 + width), 0);
height = math.max(math.floor(0.5 + height), 0);
align_x = math.min(math.max(align_x / 100, -1), 1);
align_y = math.min(math.max(align_y / 100, -1), 1);
line = math.max(line, 0);
color = math.floor(0.5 + color) % 2 ^ 24;
color_back = math.floor(0.5 + color_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);


-- further calculations.
if width <= 0 or height <= 0 then return end
local big_radius = math.max(width, height, 4000);
if color == color_back and alpha_back >= 1 then line = big_radius end
local do_fill = 2 * line - 1 >= math.min(width, height);
local shape_name = ({
	"円", "円(凹)", "菱形", "四角形(凹)",
	"正8角形", "正8角形(凹)", "正8角形(凹斜)", "正12角形", "正12角形(凹)", "正12角形(凹斜)",
	"スパイク", "スパイク(凹)",
})[shape + 1] or "円";

-- make rectangle.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.cx, obj.cy = -width * align_x / 2, -height * align_y / 2;
if line <= 0 and alpha_back <= 0 then return end

-- parepare the common parameters.
local function full_escape_repl(s) return "\\"..s:byte() end
local function full_escape(s) return ("%q"):format(s):gsub("[\128-\255]", full_escape_repl) end
local pi_head = ("radii=require'string.buffer'.decode%s,shapes=require'string.buffer'.decode%s,line="):format(
	full_escape(buffer.encode(PI.radii)), full_escape(buffer.encode(PI.shapes)));

-- render the background first.
if do_fill or alpha_back > 0 then
	obj.clearbuffer("object", do_fill and color or color_back);
	obj.effect("四隅丸め@Basic_S", "半径", radius,
		"半径均一", uniform, "右上半径", r_RT, "右下半径", r_RB, "左下半径", r_LB,
		"縦横比", aspect, "縦横比固定", fixed_aspect, "形状", shape_name, "PI",
		pi_head..math.max(width, height, 4000));
	if do_fill then return end
	if line <= 0 then
		if alpha_back < 1 then
			obj.effect("透明度適用@Basic_S", "透明度", 100 * (1 - alpha_back));
		end
		return;
	end
	obj.copybuffer("tempbuffer", "object");
end

-- next the chrome part.
if line > 0 then
	obj.clearbuffer("object", color);
	obj.effect("四隅丸め@Basic_S", "半径", radius,
		"半径均一", uniform, "右上半径", r_RT, "右下半径", r_RB, "左下半径", r_LB,
		"縦横比", aspect, "縦横比固定", fixed_aspect, "形状", shape_name, "PI",
		pi_head..line);
else obj.clearbuffer("object") end

-- combine them by shader.
obj.pixelshader("combine", "object", { "object", "tempbuffer" }, {
	alpha_back;
});

@楕円
--information:楕円@Basic_S v1.10 (for beta19a) by σ軸
--label:Basic_S\図形
--track@width:幅,0,4000,100,1
--track@height:高さ,0,4000,100,1
--track@align_x:水平揃え,-100,100,0,0.001
--track@align_y:垂直揃え,-100,100,0,0.001
--track@line:ライン幅,0,4000,4000,0.01
--color@color:色,0xffffff
--color@color_back:背景色,0xffffff
--track@alpha_back:背景透明度,0,100,100,0.01
--check@circle:真円,0
--value@PI:PI,{}
--[[pixelshader@combine:
Texture2D chm : register(t0);
Texture2D bkg : register(t1);
cbuffer constant0 : register(b0) {
	float a_back;
};
float4 combine(float4 pos : SV_Position) : SV_Target
{
	float4
		col_bkg = bkg.Load(int3(pos.xy, 0)),
		col_chm = chm.Load(int3(pos.xy, 0));
	col_bkg *= a_back * max(1 - (col_bkg.a > 0 ? col_chm.a / col_bkg.a : 0), 0);
	return col_chm + col_bkg;
}
]]
local obj, math, tonumber, type = obj, math, tonumber, type;

-- take parameters.
--[==[
	PI = {
		width:		number?,
		height:		number?,
		align_x:	number?,
		align_y:	number?,
		line:		number?,
		color:		number?,
		color_back:	number?,
		alpha_back:	number?,
		circle:		boolean|number|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
align_x = tonumber(PI.align_x) or align_x;
align_y = tonumber(PI.align_y) or align_y;
line = tonumber(PI.line) or line;
color = tonumber(PI.color) or color;
color_back = tonumber(PI.color_back) or color_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
circle = as_bool(PI.circle, circle ~= 0);

-- normalize parameters.
width = math.max(math.floor(0.5 + width), 0);
height = math.max(math.floor(0.5 + height), 0);
align_x = math.min(math.max(align_x / 100, -1), 1);
align_y = math.min(math.max(align_y / 100, -1), 1);
line = math.max(line, 0);
color = math.floor(0.5 + color) % 2 ^ 24;
color_back = math.floor(0.5 + color_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);

-- further calculations.
if circle then height = width end
if width <= 0 or height <= 0 then return end
local big_radius = math.max(width, height, 4000);
if color == color_back and alpha_back >= 1 then line = big_radius end
local do_fill = 2 * line - 1 >= math.min(width, height);

-- make rectangle.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.cx, obj.cy = -width * align_x / 2, -height * align_y / 2;
if line <= 0 and alpha_back <= 0 then return end

-- render the background first.
if do_fill or alpha_back > 0 then
	obj.clearbuffer("object", do_fill and color or color_back);
	obj.effect("四隅丸め@Basic_S", "半径", big_radius,
		"縦横比固定", 0, "形状", "円", "PI", "line="..big_radius);
	if do_fill then return end
	if line <= 0 then
		if alpha_back < 1 then
			obj.effect("透明度適用@Basic_S", "透明度", 100 * (1 - alpha_back));
		end
		return;
	end
	obj.copybuffer("tempbuffer", "object");
end

-- next the chrome part.
obj.clearbuffer("object", color);
obj.effect("四隅丸め@Basic_S", "半径", big_radius,
	"縦横比固定", 0, "形状", "円", "PI", "line="..line);

-- combine them by shader.
obj.pixelshader("combine", "object", { "object", "tempbuffer" }, {
	alpha_back;
});

@菱形
--information:菱形@Basic_S v1.10 (for beta19a) by σ軸
--label:Basic_S\図形
--track@width:幅,0,4000,100,1
--track@height:高さ,0,4000,100,1
--track@align_x:水平揃え,-100,100,0,0.001
--track@align_y:垂直揃え,-100,100,0,0.001
--track@line:ライン幅,0,4000,4000,0.01
--color@color:色,0xffffff
--color@color_back:背景色,0xffffff
--track@alpha_back:背景透明度,0,100,100,0.01
--check@square:正方形,0
--value@PI:PI,{}
--[[pixelshader@combine:
Texture2D chm : register(t0);
Texture2D bkg : register(t1);
cbuffer constant0 : register(b0) {
	float a_back;
};
float4 combine(float4 pos : SV_Position) : SV_Target
{
	float4
		col_bkg = bkg.Load(int3(pos.xy, 0)),
		col_chm = chm.Load(int3(pos.xy, 0));
	col_bkg *= a_back * max(1 - (col_bkg.a > 0 ? col_chm.a / col_bkg.a : 0), 0);
	return col_chm + col_bkg;
}
]]
local obj, math, tonumber, type = obj, math, tonumber, type;

-- take parameters.
--[==[
	PI = {
		width:		number?,
		height:		number?,
		align_x:	number?,
		align_y:	number?,
		line:		number?,
		color:		number?,
		color_back:	number?,
		alpha_back:	number?,
		square:		boolean|number|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
align_x = tonumber(PI.align_x) or align_x;
align_y = tonumber(PI.align_y) or align_y;
line = tonumber(PI.line) or line;
color = tonumber(PI.color) or color;
color_back = tonumber(PI.color_back) or color_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
square = as_bool(PI.square, square ~= 0);

-- normalize parameters.
width = math.max(math.floor(0.5 + width), 0);
height = math.max(math.floor(0.5 + height), 0);
align_x = math.min(math.max(align_x / 100, -1), 1);
align_y = math.min(math.max(align_y / 100, -1), 1);
line = math.max(line, 0);
color = math.floor(0.5 + color) % 2 ^ 24;
color_back = math.floor(0.5 + color_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);

-- further calculations.
if square then height = width end
if width <= 0 or height <= 0 then return end
local big_radius = math.max(width, height, 4000);
if color == color_back and alpha_back >= 1 then line = big_radius end
local do_fill = 2 * line - 1 >= math.min(width, height);

-- make rectangle.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.cx, obj.cy = -width * align_x / 2, -height * align_y / 2;
if line <= 0 and alpha_back <= 0 then return end

-- render the background first.
if do_fill or alpha_back > 0 then
	obj.clearbuffer("object", do_fill and color or color_back);
	obj.effect("四隅丸め@Basic_S", "半径", big_radius,
		"縦横比固定", 0, "形状", "菱形", "PI", "line="..big_radius);
	if do_fill then return end
	if line <= 0 then
		if alpha_back < 1 then
			obj.effect("透明度適用@Basic_S", "透明度", 100 * (1 - alpha_back));
		end
		return;
	end
	obj.copybuffer("tempbuffer", "object");
end

-- next the chrome part.
obj.clearbuffer("object", color);
obj.effect("四隅丸め@Basic_S", "半径", big_radius,
	"縦横比固定", 0, "形状", "菱形", "PI", "line="..line);

-- combine them by shader.
obj.pixelshader("combine", "object", { "object", "tempbuffer" }, {
	alpha_back;
});

@スーパー楕円
--information:スーパー楕円@Basic_S v1.10 (for beta19a) by σ軸
--label:Basic_S\図形
--track@exponent:膨らみ,-300,300,-60,0.001
--track@width:幅,0,4000,100,1
--track@height:高さ,0,4000,100,1
--track@align_x:水平揃え,-100,100,0,0.001
--track@align_y:垂直揃え,-100,100,0,0.001
--track@line:ライン幅,0,4000,4000,1
--color@color:色,0xffffff
--color@color_back:背景色,0xffffff
--track@alpha_back:背景透明度,0,100,100,0.01
--check@symmetric:縦横一致,0
--value@PI:PI,{}
--[[pixelshader@carve:
cbuffer constant0 : register(b0) {
	float2 r_hsize; float e;
};
float4 carve(float4 pos : SV_Position) : SV_Target
{
	const float2 p = r_hsize * pos.xy - 1;
	const float v = 1 - dot(pow(abs(p), e), 1),
		d = fwidth(v),
		l = d > 0 ? v / d : sign(v);
	return float4(0, 0, 0, saturate(l + 0.5));
}
]]
local obj, math, tonumber, type = obj, math, tonumber, type;

-- take parameters.
--[==[
	PI = {
		exponent:	number?,
		width:		number?,
		height:		number?,
		align_x:	number?,
		align_y:	number?,
		line:		number?,
		color:		number?,
		color_back:	number?,
		alpha_back:	number?,
		symmetric:	boolean|number|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
exponent = tonumber(PI.exponent) or exponent;
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
align_x = tonumber(PI.align_x) or align_x;
align_y = tonumber(PI.align_y) or align_y;
line = tonumber(PI.line) or line;
color = tonumber(PI.color) or color;
color_back = tonumber(PI.color_back) or color_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
symmetric = as_bool(PI.symmetric, symmetric ~= 0);

-- normalize parameters.
exponent = math.min(math.max(exponent / 100, -3), 3);
width = math.max(math.floor(0.5 + width), 0);
height = math.max(math.floor(0.5 + height), 0);
align_x = math.min(math.max(align_x / 100, -1), 1);
align_y = math.min(math.max(align_y / 100, -1), 1);
line = math.max(math.floor(0.5 + line), 0);
color = math.floor(0.5 + color) % 2 ^ 24;
color_back = math.floor(0.5 + color_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);

-- further calculations.
if symmetric then height = width end
if width <= 0 or height <= 0 then return end
local big_radius = math.max(width, height, 4000);
if color == color_back and alpha_back >= 1 then line = big_radius end
local do_fill = 2 * line - 1 >= math.min(width, height);

-- make rectangle.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.cx, obj.cy = -width * align_x / 2, -height * align_y / 2;
if line <= 0 and alpha_back <= 0 then return end
obj.clearbuffer("object", do_fill and color or color_back);

-- e = (3 + e')/(3 - e'), astroid at e' = -3/5.
-- e = 0 is replaced by some E < log(2)/log((w/2) / 0.5),
-- e = oo can be replaced by some E > -log(2)/log(1-0.5/w);
-- where w is the maximum possible length.
local e = (3 + exponent) / (3 - exponent);
if exponent >= 3 or e > 1.39 * math.max(width, height) then
	-- e is recognized as inifinity (log(2) ~ 0.693147).
	-- nothing to do.
else
	if exponent <= -3 or e < 1 / 14 then
		-- e is recognized as zero.
		e = 1 / 14; -- max(w, h) is at most 2 ^ 14.
	end
	-- carve the shape by shader.
	obj.pixelshader("carve", "object", nil, {
		2 / width, 2 / height; e;
	}, "mask");
end

-- draw the outline.
if not do_fill then
	obj.effect("縁取りα@Basic_S", "サイズ", -line, "ぼかし", 0,
		"縁色", color, "前景透明度", 100 * (1 - alpha_back))
end
